# №2

'''
Логическая функция F задаётся выражением:
(¬x ∧ y ∧ z) ∨ (¬x ∧ ¬y ∧ z) ∨ (¬x ∧ ¬y ∧ ¬z).
На рисунке приведён фрагмент таблицы истинности функции F, содержащий все наборы аргументов, при которых функция F истинна.
Определите, какому столбцу таблицы истинности функции F соответствует каждая из переменных x, y, z.
'''

for x in range(2):
    for y in range(2):
        for z in range(2):
            if (not(x) and y and z) or (not(x) and not(y) and z) or (not(x) and not (y) and not(z)) == 1:
                print(x, y, z)


'''
Логическая функция F задаётся выражением (¬z)∧x ∨ x∧y. Определите, какому столбцу таблицы истинности функции F соответствует каждая из переменных x, y, z.
В ответе напишите буквы x, y, z в том порядке, в котором идут соответствующие им столбцы 
(сначала – буква, соответствующая 1-му столбцу; затем – буква, соответствующая 2-му столбцу; 
затем – буква, соответствующая 3-му столбцу). Буквы в ответе пишите подряд, никаких разделителей между буквами ставить не нужно.
'''

for x in range(2):
    for z in range(2):
        for y in range(2):
            if (not(z) and x) or (x and y) == 1:
                print(x, y, z)

# №4

'''
Для кодирования букв И, Д, Т, О, X решили использовать двоичное представление чисел 0, 1, 2, 3 и 4 соответственно 
(с сохранением одного незначащего нуля в случае одноразрядного представления). 
Закодируйте последовательность букв ТИХОХОД таким способом и результат запишите шестнадцатеричным кодом.
'''

print(int("1000100111001101", base=2))
print(f"{35277:x}")

# №5

#1
for n in range(1, 103):
    if n % 2 == 0:
        r = str(bin(n)) + "01"
    else:
        r = str(bin(n)) + "10"
    if int(r, 2) > 102:
        print(int(r, 2))
        break

'''
На вход алгоритма подаётся натуральное число N. Алгоритм строит по нему новое число R следующим образом.
1. Строится двоичная запись числа N.
2. К этой записи дописываются справа ещё два разряда по следующему правилу:
а) складываются все цифры двоичной записи, и остаток от деления суммы на 2 дописывается в конец числа (справа). 
Например, запись 10000 преобразуется в запись 100001;
б) над этой записью производятся те же действия — справа дописывается остаток от деления суммы цифр на 2.
Полученная таким образом запись (в ней на два разряда больше, чем в записи исходного числа N) 
является двоичной записью искомого числа R.
Укажите такое наименьшее число N, для которого результат работы алгоритма больше 77. 
В ответе это число запишите в десятичной системе счисления.
'''

for n in range(1, 78):
    r = str(bin(n))
    if r.count("1") % 2 == 0:
        r = str(bin(n)) + "00"
    else:
        r = str(bin(n)) + "10"
    if int(r, 2) > 77:
        print(n, int(r, 2))
        break

#3

for i in range(10000, 100000):
    n = str(i)
    a = int(n[0]) + int(n[2]) + int(n[4])
    b = int(n[1]) + int(n[3])
    if min(a, b) == 7 and max(a, b) == 23:
        print(i)
        break

#4

for i in range(1, 37):
    n = str(bin(i)[2:])
    if n.count("1") > n.count("0"):
        n += "1"
    else:
        n += "0"
    n = int(n, base=2)
    if n > 36:
        print(n)
        break

# №6

'''
Сколько существует положительных чисел, подаваемых на вход программе,
при которых программа в результате своей работы выведет на экран одно положительное число?

d = int(input())
n = 20
s = 40
while s + n < d:
  s = s – 10
  n = n - 20
print(n)
'''

for i in range(1, 10000):
    d = i
    n = 20
    s = 40
    while s + n < d:
        s = s - 10
        n = n - 20
    if n > 0:
        print(i)

# №17

'''
Рассматривается множество целых чисел, принадлежащих числовому отрезку [5883; 15906], которые делятся
на 9 или 23 и не делятся на 13, 18, 19, 22.
Найдите количество таких чисел и максимальное из них.
В ответе запишите два целых числа без пробелов и других дополнительных символов:
сначала количество, затем максимальное число.
'''

A = [i for i in range(5883, 15906)
     if i % 9 == 0 or i % 23 == 0 and i % 13 != 0 and i % 18 != 0 and i % 19 != 0 and i % 22 != 0]
print(len(A), max(A)) #лучше так

k = 0
m = -1
for i in range(5883, 15907):
    if i % 9 == 0 or i % 23 == 0:
        if i % 13 != 0 and i % 18 != 0 and i % 19 != 0 and i % 22 != 0:
            k += 1
            m = max(m, i)
print(k, m)

'''
Определите количество принадлежащих отрезку [2 · 10^10; 4 · 10^10] натуральных чисел, которые делятся на
7 и на 100 000 и при этом не делятся на 13, 29, 43 и 101, а также наименьшее из таких чисел. 
В ответе запишите два целых числа без пробелов и других дополнительных символов: 
сначала количество, затем наименьшее число.
'''

A = [i for i in range(2*10**5, 4*10**5+1)
     if i % 7 == 0 and i % 13 != 0 and i % 29 != 0 and i % 43 != 0 and i % 101 != 0]
print(f"{len(A), min(A)}00000") #лучше так

k = 0
m = 1000000
for i in range(2*10**5, 4*10**5+1):
    if i % 7 == 0:
            if i % 13 != 0 and i % 29 != 0 and i % 43 != 0 and i % 101 != 0:
                k += 1
                m = min(m, i)
print(k, m) #незабыть 5 нулей на конце

'''
Рассматривается множество целых чисел, принадлежащих числовому отрезку [9999; 99999], которые кратны сумме своих цифр. 
Найдите количество таких чисел и максимальное из них. В ответе запишите два целых числа: 
сначала количество, затем – максимальное число.
'''

def sumDigits(e):
    sumi = 0
    while e != 0:
        sumi += e % 10
        e = e // 10
    return sumi

k = 0
m = -1
for i in range(9999, 100000):
    if i % sumDigits(i) == 0:
        k += 1
        m = max(m, i)
print(k, m)
#или
A = [i for i in range(9999, 100000) if i % sumDigits(i) == 0]
print(len(A), max(A))

'''
Рассматривается множество целых чисел, принадлежащих числовому отрезку [256; 2566], 
которые делятся на 7 и не делятся на 21, 23, 31.
Найдите сумму таких чисел и максимальное из них.
В ответе запишите два целых числа: сначала сумму, затем максимальное число.
'''

A = [i for i in range(256, 2567) if i % 7 == 0 and i % 21 != 0 and i % 23 != 0 and i % 31 != 0]
print(sum(A), max(A))
#или
k = 0
m = -1
for i in range(256, 2567):
    if i % 7 == 0:
        if i % 21 != 0 and i % 23 != 0 and i % 31 != 0:
            k += i
            m = max(m, i)
print(k, m)

'''
Назовём натуральное число подходящим, если ровно два из его делителей входят в список (11, 13, 17, 19). 
Определите количество подходящих чисел, принадлежащих отрезку [11000; 22000], 
а также наименьшее из таких чисел. В ответе запишите два целых числа: 
сначала количество, затем, без разделительных знаков, наименьшее число.
'''

k = 0
m = 34000
s1 = {11, 13, 17, 19}

for i in range(11000, 22001):
    s2 = set() #создаём пустое множество
    for u in range(1, i + 1):
        if i % u == 0:
            s2.add(u)
    if len(s1.intersection(s2)) == 2: #если в s2 есть ровно 2 делителя входящие в s1, то... (intersection - сравнение двух множеств)
        k += 1
        m = min(m, i)
print(k, m)